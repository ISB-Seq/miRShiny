{
    "collab_server" : "",
    "contents" : "library(ggplot2)\nlibrary(limma)\nlibrary(RColorBrewer)\nlibrary(DESeq2)\nlibrary(edgeR)\nlibrary(shiny)\nlibrary(reshape)\nlibrary(viridis)\nlibrary(sva)\nlibrary(grid)\nlibrary(reader)\nlibrary(NMF)\nlibrary(plyr)\nlibrary(RnaSeqSampleSize)\nlibrary(circlize)\nlibrary(openxlsx)\nlibrary(heatmaply)\n#library(pwr)\n\n\n#######\nshinyServer(function(input, output) {\n  ##########################\n  \n  storageValues <- reactiveValues()\n  \n  theme_set(theme_bw())\n  \n  theme_update(axis.title = element_text(face = \"italic\"), plot.title = element_text(hjust = 0.5, size = 15, face = \"plain\"), legend.position = \"bottom\",\n               legend.direction = \"horizontal\", panel.border = element_rect(fill = NA, colour = \"grey50\"))\n  \n  #############################\n  \n  #make Conditions File selecton, add voom to normalize matrix function\n  \n  rawElist <- eventReactive(input$upload, ignoreNULL = FALSE, {\n    if ((!is.null(input$files) && !is.null(input$condition)) || input$sampleData) {\n      withProgress(message = 'Reading files', value = 0, {\n        #read in matrix file\n        if(input$sampleData){\n          matrix <- read.csv(file = \"MCW_CRC_Exo_Matrix.csv\", header = TRUE, row.names = 1, check.names = FALSE)\n        } else{\n          sep <- get.delim(win(input$files$datapath), n = 40, skip = 1)\n          print(\"Inferred Delimiter:\")\n          print(get.delim(win(input$files$datapath), n = 40, skip = 1))\n          matrix <-\n            read.table(\n              win(input$files$datapath),\n              row.names = 1,\n              header = TRUE,\n              sep = sep,\n              #changed sep = sep to sep = \"\\t\" to test\n              check.names = FALSE\n            )\n          \n          #debug print\n          #print(is.na(matrix))\n          #print(matrix)\n          # sim shows 0 columns for singleassign mis=0\n          #print(str(matrix))\n        }\n        incProgress(1 / 6, detail = 'Reading matrix')\n        \n        #debug print\n        #print(matrix, digits = 5)\n        \n        #clean matrix data\n        incProgress(1 / 6, detail = 'Cleaning matrix data')\n        if(length(unique(colnames(matrix))) != ncol(matrix)){\n          showModal(modalDialog(\n            title = \"Error Processing Input\",\n            \"Sample Labels (Columns) Duplicated or Missing.\"\n          ))\n          return(NULL)\n        }\n        \n        \n        matrix[is.na(matrix)] <- 0\n        matrix[is.null(matrix)] <- 0\n        matrix[matrix < 0] <- 0\n        matrix <- floor(matrix)\n        \n        #debug print\n        #Error is Triggered Here\n        #print(matrix)\n        \n        #read in Conditions File\n        incProgress(1 / 6, detail = 'Getting conditions')\n        if(input$sampleData){\n          condition <-\n            read.csv(\n              file = \"MCW_CRC_Exo_Conditions.csv\", \n              header = TRUE,\n              check.names = FALSE\n            )\n        } else{\n          condSep <- get.delim(win(input$condition$datapath), n = 10, skip = 1)\n          if(is.na(condSep)){\n            condSep <- NULL\n          }\n          condition <-\n            read.table(\n              win(toString(input$condition$datapath)), \n              header = TRUE,\n              sep = condSep,\n              check.names = FALSE\n            )\n        }\n        \n        # debug print\n        # print(matrix, digits = 5)\n        \n        #checking objects\n        incProgress(1 / 6, detail = 'Checking objects')\n        if (ncol(matrix) != nrow(condition)) {\n          showModal(modalDialog(\n            title = \"Error Processing Input\",\n            \"Possible missing data. Dimensions of Expression Data and Conditions File do not correspond.\"\n          ))\n          return(NULL)\n        }\n        if (is.null(condition$condition)) {\n          showModal(modalDialog(\n            title = \"Error Processing Input\",\n            \"\\\"condition\\\" column is missing or incorrectly named.\"\n          ))\n          return(NULL)\n        }\n        if (ncol(matrix) <= 1) {\n          showModal(modalDialog(\n            title = \"Error Processing Input\",\n            \"Expression file has too few rows or is incorrectly formatted. \"\n          ))\n          return(NULL)\n        }\n        \n        #debug print\n        #print(matrix, digits = 5)\n        \n        #build elist objects\n        incProgress(1 / 6, detail = 'Building expression list objects')\n        ##make genes list\n        elistraw.genes <-\n          data.frame(factor(row.names(matrix)), factor(row.names(matrix)))\n        colnames(elistraw.genes) <-\n          c(\"ProbeName\", \"SystematicName\")\n        \n        ##make targets file\n        elistraw.targets <-\n          data.frame(colnames(matrix), make.names(condition$condition))\n        cn <- c(\"FileName\", \"Condition\")\n        \n        if (!is.null(condition$group)) {\n          elistraw.targets$group <- condition$group\n          cn <- c(cn, \"group\")\n        }\n        if (!is.null(condition$normalizer)) {\n          elistraw.targets$normalizer <- condition$normalizer\n          cn <- c(cn, \"normalizer\")\n        }\n        if (!is.null(condition$batch)) {\n          elistraw.targets$batch <- condition$batch\n          cn <- c(cn, \"batch\")\n        }\n        \n        colnames(elistraw.targets) <- cn\n        \n        ##make E\n        elistraw.e <- data.matrix(matrix)\n        elistraw.list <- list()\n        \n        incProgress(1 / 3, detail = 'Generating new expression list')\n        elistraw <- new(\"EListRaw\", elistraw.list)\n        elistraw$E <- elistraw.e\n        elistraw$genes <- elistraw.genes\n        elistraw$targets <- elistraw.targets\n        \n        showModal(modalDialog(\n          title = \"Data Read Successfully\",\n          \"Uploaded files were successfully read. Proceed to Normalization or reupload a different set of data.\"\n        ))\n        return(elistraw)\n      })\n    } else{\n      return(NULL)\n    }\n  })\n  \n  \n  processedElist <-\n    eventReactive(input$processData, ignoreNULL = FALSE, {\n      if (is.null(rawElist()) || input$processData == 0) {\n        return(NULL)\n      } else {\n        withProgress(message = 'Processing data', value = 0, {\n          #get cleaned raw data\n          rawEL <- rawElist()\n          \n          #subset\n          if (!is.null(rawEL$targets$group)) {\n            rawEL <- rawEL[, subsetVector()]\n          }\n          \n          #mark low values\n          incProgress(0.25, detail = \"Marking low value genes\")\n          if (input$filtThresh == \"Global Mean\") {\n            filterVector <-\n              filterProbes(rawEL,\n                           threshVal = \"Global Mean\",\n                           percentSamples = (input$filtPercent %% 100))\n          } else {\n            filterVector <-\n              filterProbes(\n                rawEL,\n                threshVal = input$filtThreshVal,\n                percentSamples = (input$filtPercent %% 100)\n              )\n          }\n          \n          #normalize / check voom\n          incProgress(0.25, detail = \"Applying normalization and evaluating batches\")\n          \n          if (input$norm == \"DESeq\") {\n            row.names(rawEL$E) <- rawEL$genes$SystematicName\n            countData <- ceiling(rawEL$E)\n            colData <-\n              data.frame(as.character(rawEL$targets$Condition))\n            \n            colnames(colData) <- c(\"condition\")\n            row.names(colData) <- rawEL$targets$FileName\n            \n            dds <-\n              DESeqDataSetFromMatrix(\n                countData = countData,\n                colData = colData,\n                design = ~ condition\n              )\n            dds <- estimateSizeFactors(dds)\n            \n            normEL <-\n              normalizeBetweenArrays(rawEL, method = \"none\")\n            if (input$voom == FALSE) {\n              normE <- counts(dds, normalized = TRUE)\n              normE <- log2(normE + 1) #avoid log(0) error\n              normEL$E <- normE\n            } else {\n              normE <- counts(dds, normalized = TRUE)\n              v <- voom(normE+0.5, plot = FALSE)\n              normEL$E <- v$E\n            }\n            \n          } else if (input$norm == \"TMM\") {\n            row.names(rawEL$E) <- rawEL$genes$SystematicName\n            countData <- ceiling(rawEL$E)\n            \n            colData <- as.character(rawEL$targets$Condition)\n            \n            er <- DGEList(counts = countData, group = colData)\n            er <- calcNormFactors(er)\n            \n            normEL <-\n              normalizeBetweenArrays(rawEL, method = \"none\")\n            normE <- cpm(er, normalized.lib.sizes = TRUE)\n            \n            if (input$voom == FALSE) {\n              normE <- log2(normE + 1)\n              normEL$E <- normE\n            }\n            else{\n              v <- voom(normE+0.5, plot = FALSE)\n              normEL$E <- v$E\n            }\n            \n          } else if (input$norm == \"Quantile\" || input$norm == \"CyclicLoess\" || input$norm == \"Scale\" || input$norm == \"None\") {\n            if (input$voom == FALSE) {\n              rawEL$E <- rawEL$E + 1 #avoid log(0) error\n              normEL <-\n                normalizeBetweenArrays(rawEL, method = tolower(input$norm))\n            } else{\n              v <-\n                voom(rawEL$E+0.5,\n                     plot = FALSE,\n                     normalize.method = tolower(input$norm))\n              #create elist object from elistraw\n              normEL <-\n                normalizeBetweenArrays(rawEL, method = \"none\")\n              #replace E with voom-generated E\n              normEL$E <- v$E\n            }\n          } else if(input$norm == \"VSN\"){\n            normEL <-\n              normalizeBetweenArrays(rawEL, method = \"none\")\n            normEL$E <- justvsn(rawEL$E)\n          } else {\n            #CPM, total count, UQ, housekeeping, median\n            normEL <-\n              normalizeBetweenArrays(rawEL, method = \"none\")\n            #housekeeping gene\n            if (input$norm == \"Housekeeping Gene\") {\n              if (input$housekeep == \"Custom vector (\\\"normalizer\\\")\" && !is.null(rawEL$targets$normalizer)) {\n                normEL$E <-\n                  normalizeMatrix(input$norm,\n                                  rawEL$E,\n                                  rawEL$targets$normalizer,\n                                  voom = input$voom)\n              }\n              else{\n                normEL$E <-\n                  normalizeMatrix(input$norm,\n                                  rawEL$E,\n                                  rawEL$E[input$housekeep,],\n                                  voom = input$voom)\n              }\n            } else{\n              normEL$E <-\n                normalizeMatrix(input$norm, rawEL$E, voom = input$voom)\n            }\n          }\n          \n          storageValues$noFiltElist <- normEL\n          \n          #clear out prior instances of sva objects\n          storageValues$sv <- NULL\n          storageValues$svaE <- NULL\n          \n          #remove negative counts\n          normEL$E[normEL$E < 0] <- 0\n          \n          if(!is.null(normEL$targets$batch)){\n            if(input$batchCorrect == \"sva\"){\n              mod1 <- model.matrix(~as.factor(normEL$targets$Condition));\n              mod0 <- model.matrix(~1,data=normEL$targets); \n              normEL$E <- (2 ^ normEL$E) - 1\n              if(input$svaN == \"Auto\"){\n                svaobj <- svaseq(normEL$E, mod1, mod0);\n              } else{\n                svaobj <- svaseq(normEL$E, mod1, mod0, n.sv = as.integer(input$svaN));\n              }\n              \n              \n              storageValues$sv <- svaobj$sv\n              storageValues$svaE <- cleanE(normEL$E, mod1, svaobj$sv)\n              normEL$E <- log2(normEL$E+1)\n            } else if(input$batchCorrect == \"comBat\"){\n              normEL$E <- (2 ^ normEL$E) - 1\n              mod.combat <- model.matrix(~1, data = normEL$targets)\n              combatE <- ComBat(dat = normEL$E, batch = normEL$targets$batch, mod = mod.combat, par.prior = TRUE, prior.plots = FALSE)\n              \n              normEL$E <- log2(combatE+1)\n            } else if(input$batchCorrect == \"Targetted Recentering\"){\n              if(!is.null(input$trGrps) && !setequal(unique(rawElist()$targets$group), input$trGrps)){\n                normEL$E <- (2 ^ normEL$E) - 1\n                groups <- input$trGrps\n                groupVector <- rawElist()$targets$group\n                E <- normEL$E\n                for(i in 1:length(groups)){\n                  target <- groups[i]\n                  inGrp <- groupVector %in% target\n                  outGrp <- !(groupVector %in% groups)\n                  for(j in 1:10){\n                    diff <- mean(E[,inGrp]) - mean(E[,outGrp]) \n                    E[,inGrp] <- E[,inGrp] - diff\n                    E[E < 0] <- 0\n                  }\n                }\n                normEL$E <- log2(E+1)\n              }\n            }\n          }\n          \n          #filter\n          incProgress(0.25, detail = \"Filtering out low count genes\")\n          normEL <- normEL[filterVector,]\n          \n          incProgress(0.25, detail = \"Reformatting data\")\n          Sys.sleep(0.1)\n          showModal(modalDialog(\n            title = \"Data Processed Successfully\",\n            \"Uploaded raw data was successfully normalized and filtered.\"\n          ))\n          return(normEL)\n        })\n      }\n    })\n  \n  \n  topTableList <- reactive({\n    if(!(is.null(processedElist()) || is.null(input$condition1) || is.null(input$condition2))){\n      if(length(intersect(input$condition1, input$condition2)) == 0){\n        withProgress(message = 'Performing DE Analysis', value = 0, {\n          incProgress(0.2, detail = \"Getting expression values\")\n          normEL <- processedElist()\n          \n          \n          \n          #create contrast string\n          incProgress(0.2, detail = \"Making contrasts\")\n          \n          condition2 <- input$condition2\n          if(length(condition2)>1){\n            l2 <- length(condition2)\n            condition2 <- paste(condition2, collapse = \"+\")\n            condition2 <- paste0(\"(\", condition2, \")/\", l2)\n          }\n          condition1 <- input$condition1\n          if(length(condition1)>1){\n            l1 <- length(condition1)\n            condition1 <- paste(condition1, collapse = \"+\")\n            condition1 <- paste0(\"(\", condition1, \")/\", l1)\n          }\n          \n          contrast <-\n            paste(condition2, \"-\", condition1, sep = \"\")\n          \n          #design model matrix\n          incProgress(0.25, detail = \"Building model matrix\")\n          f <- factor(normEL$targets$Condition, levels = unique(normEL$targets$Condition))\n          design <- model.matrix(~0 + f)\n          colnames(design) <- levels(f)\n          if(!is.null(storageValues$sv)){\n            design <- cbind(design, storageValues$sv)\n            a <- c(levels(f), paste(\"Surrogate\",seq_along(1:ncol(storageValues$sv)),sep = \"\"))\n            colnames(design) <- a\n          }\n          \n          #make lmfit\n          incProgress(0.25, detail = \"Applying linear model\")\n          fit <- lmFit(normEL, design)\n          cont.matrix <- makeContrasts(contrasts = contrast, levels = design)\n          secondfit <- contrasts.fit(fit, cont.matrix)\n          secondfit <- eBayes(secondfit)\n          \n          #create top table for mir expression\n          incProgress(0.1, detail = \"Labelling DE features\")\n          tt <-\n            topTable(\n              secondfit,\n              adjust = \"BH\",\n              coef = 1,\n              number = 3000,\n              sort.by = \"logFC\"\n            )\n          return(tt)\n        })\n      }\n      else{\n        return(NULL)\n      }\n    } else {\n      return(NULL)\n    }\n  })\n  \n  #  #  #  #  #  #  #  #  #  #  #  #  #  #\n  \n  #List all uploaded files, with condition\n  output$uploadStatusTable <- renderTable({\n    input$upload\n    input$condition\n    input$files\n    input$sampleData\n    isolate({\n      table <-\n        cbind(c(\"Expression File\", \"Conditions File\"),\n              c(\"-\", \"-\"),\n              c(\"No\", \"No\"),\n              c(\"No\", \"No\"),\n              c(\"-\", \"-\"),\n              c(\"-\", \"-\"))\n      colnames(table) <-\n        c(\"File Type\", \"File Name\", \"File Uploaded?\", \"File Read?\", \"Samples\", \"Features\")\n      if (!is.null(input$files$datapath)) {\n        files <- input$files\n        table[1, 2] <- toString(files$name[1])\n        table[1, 3] <- \"Yes\"\n        table[1, 4] <- \"No\"\n      }\n      if (!is.null(input$condition$datapath)) {\n        condition <- input$condition\n        table[2, 2] <- toString(condition$name[1])\n        table[2, 3] <- \"Yes\"\n        table[2, 4] <- \"No\"\n      }\n      if(input$sampleData){\n        table[1, 2] <- \"MCW_CRC_Exo_Matrix.csv\"\n        table[1, 3] <- \"Yes\"\n        table[1, 4] <- \"No\"\n        table[2, 2] <- \"MCW_CRC_Exo_Conditions.csv\"\n        table[2, 3] <- \"Yes\"\n        table[2, 4] <- \"No\"\n      }\n      if (!is.null(rawElist())) {\n        table[1, 4] <- \"Yes\"\n        table[2, 4] <- \"Yes\"\n        table[1, 5] <- ncol(rawElist()$E)\n        table[2, 5] <- nrow(rawElist()$targets)\n        table[1, 6] <- nrow(rawElist()$E)\n      }\n      return(table)\n    })\n  })\n  \n  output$normStatusTable <-\n    renderTable({\n      input$processData\n      vec <- rep(\"-\", 7)\n      m <- matrix(vec, 1, 7)\n      colnames(m) <- c(\"Subgroups Processed\", \"Normalization Method\", \"Batch Correction\", \"Filtering Cutoff\", \"Filtering Sample Threshold\", \"miRNAs Remaining\", \"Used voom?\")\n      isolate(\n        if (!is.null(processedElist())) {\n          rEL <- rawElist()$E\n          pEL <- processedElist()$E\n          \n          geneRemaining <-\n            paste(nrow(pEL),\n                  \"remaining genes from\",\n                  nrow(rEL),\n                  \"initial genes.\")\n          \n          if (input$filtThresh == \"Global Mean\") {\n            filtCutoff <-\n              paste0(\"Global Mean\", \" (\", toString(sum(rEL) / (nrow(rEL) * ncol(rEL))), \")\")\n          } else{\n            filtCutoff <- input$filtThreshVal\n          }\n          \n          filtSamples <-\n            paste0(toString(ceiling(input$filtPercent * ncol(pEL) / 100)), \" (\", input$filtPercent, \"%)\")\n          \n          if(input$batchCorrect == \"sva\"){\n            batchCorrect <- paste(\"sva, \", ncol(storageValues$sv), \"surrogates\")\n          }else if(input$batchCorrect == \"Targetted Recentering\"){\n            if(!is.null(input$trGrps) && !setequal(unique(rawElist()$targets$group), input$trGrps)){\n              batchCorrect <- paste(\"Targetted recentering: \", paste(input$trGrps, collapse = \", \"))\n            } else{\n              batchCorrect <- \"None\"\n            }\n            \n          } else{\n            batchCorrect <- input$batchCorrect\n          }\n          \n          m[1,1] <- toString(input$subsetGrps)\n          m[1,2] <- input$norm\n          m[1,3] <- batchCorrect\n          m[1,4] <- filtCutoff\n          m[1,5] <- filtSamples\n          m[1,6] <- geneRemaining\n          m[1,7] <- input$voom\n        })\n      return(m)\n    }, include.colnames = TRUE, include.rownames = FALSE)\n  \n  output$upperQCPlot <- renderPlot({\n    #dont plot until button has been pushed\n    if (input$plotQC==0) {\n      return(NULL)\n    }\n    isolate(\n      if(!is.null(processedElist())) {\n        pEL <- processedElist()\n        rEL <- rawElist()\n        \n        #subset\n        if(!is.null(pEL$targets$group)) {\n          rEL <- rEL[, subsetVector()]\n        }\n        \n        if(input$plotType == \"PCA Plot\") {\n          withProgress(message = 'Generating PCA Plot', value = 0, {\n            incProgress(0.25, detail = \"Calculating PCs\")\n            matrix <- pEL$E\n            \n            pc <- prcomp(t(matrix))\n            pc1 <- pc$x[, 1]\n            pc2 <- pc$x[, 2]\n            pc3 <- pc$x[, 3]\n            \n            #fix the labels/legends\n            pVar <- round(100 * (pc$sdev) ^ 2 / sum(pc$sdev ^ 2))\n            \n            incProgress(0.25, detail = \"Sorting sample information\")\n            if(input$sortPCA == \"Condition\"){\n              colour <- factor(pEL$targets$Condition)\n            } else if(input$sortPCA == \"Group\"){\n              colour <- factor(pEL$targets$group)\n            } else if(input$sortPCA == \"Batch\"){\n              colour <- factor(pEL$targets$batch)\n            }\n            labels <- colnames(matrix)\n            \n            condition <- pEL$targets$Condition\n            comps <- data.frame(labels, pc1, pc2, pc3, colour, condition)\n            if(!is.null(pEL$targets$group)){\n              comps$group <- pEL$targets$group\n            }\n            if(!is.null(pEL$targets$batch)){\n              comps$batch <- pEL$targets$batch\n            }\n            \n            incProgress(0.25, detail = \"Generating base plot\")\n            p <- ggplot(data = comps, aes(x = pc1, y = pc2)) + geom_point(aes(colour = colour), size = 3, shape = 1) + geom_text(aes(label = labels), size = 3, hjust = 1.5) + labs(\n              title = \"Principal Component Analysis\",\n              x = paste(\"PC1 (\", pVar[1], \"%)\"),\n              y = paste(\"PC2 (\", pVar[2], \"%)\"),\n              colour = input$sortPCA\n            ) \n            \n            incProgress(0.25, detail = \"Applying facets\")\n            if(input$pcaType == \"PC1/PC2\"){\n              plotColor(p, fill = FALSE, input = input$plotColors, rev = input$colorsRev, n = length(unique(colour)))\n            } else if(input$pcaType == \"PC1/PC2 with K-means\"){\n              nClust <- switch(input$sortPCA, Batch = length(unique(pEL$targets$batch)), Group = length(unique(pEL$targets$Group)), Condition = length(unique(pEL$targets$Condition)))\n              pcCluster <- kmeans(t(matrix), nClust, nstart = 100)\n              comps$Cluster <- factor(pcCluster$cluster)\n              \n              p <- ggplot(data = comps, aes(x = pc1, y = pc2, shape = Cluster)) + geom_point(aes(colour = colour), size = 3) + geom_text(aes(label = labels), size = 3, hjust = 1.5) + labs(\n                title = \"Principal Component Analysis\",\n                x = paste(\"PC1 (\", pVar[1], \"%)\"),\n                y = paste(\"PC2 (\", pVar[2], \"%)\"),\n                colour = input$sortPCA\n              ) \n              plotColor(p, fill = FALSE, input = input$plotColors, rev = input$colorsRev, n = length(unique(colour)))\n            } else if(input$pcaType == \"PC1/PC2/PC3\"){\n              p1 <- ggplot(data = comps, aes(x = pc1, y = pc2)) + geom_point(aes(colour = colour), size = 3, shape = 1) + labs(\n                title = \"PC1/PC2\",\n                x = paste(\"PC1 (\", pVar[1], \"%)\"),\n                y = paste(\"PC2 (\", pVar[2], \"%)\"),\n                colour = input$sortPCA\n              ) \n              p2 <- ggplot(data = comps, aes(x = pc2, y = pc3)) + geom_point(aes(colour = colour), size = 3, shape = 1) + labs(\n                title = \"PC2/PC3\",\n                x = paste(\"PC2 (\", pVar[2], \"%)\"),\n                y = paste(\"PC3 (\", pVar[3], \"%)\"),\n                colour = input$sortPCA\n              ) \n              p3 <- ggplot(data = comps, aes(x = pc1, y = pc3)) + geom_point(aes(colour = colour), size = 3, shape = 1) + labs(\n                title = \"PC1/PC3\",\n                x = paste(\"PC1 (\", pVar[1], \"%)\"),\n                y = paste(\"PC3 (\", pVar[3], \"%)\"),\n                colour = input$sortPCA\n              ) \n              multiplot(p1, p2, p3, cols = 2)\n            } else if(input$pcaType == \"Facet by Condition\"){\n              plotColor(p + facet_wrap(~condition, scales = \"free\", nrow = 2), fill = FALSE, input = input$plotColors, rev = input$colorsRev, n = length(unique(colour)))\n            } else if(input$pcaType == \"Facet by Group\"){\n              plotColor(p + facet_wrap(~group, scales = \"free\", nrow = 2), fill = FALSE, input = input$plotColors, rev = input$colorsRev, n = length(unique(colour)))\n            } else if(input$pcaType == \"Facet by Batch\"){\n              plotColor(p + facet_wrap(~batch, scales = \"free\", nrow = 2), fill = FALSE, input = input$plotColors, rev = input$colorsRev, n = length(unique(colour)))\n            }\n          })\n        } else if (input$plotType == \"Correlation Coefficient Matrix\") {\n          withProgress(message = 'Generating Correlation Coefficient Matrix', value = 0, {\n            matrix <- pEL$E\n            \n            incProgress(0.25, detail = \"Sorting sample information\")\n            if(input$cctype == \"By Group\"){\n              group <- pEL$targets$group\n              \n              u <- unique(group)\n              for(i in 1:length(u)){\n                if(i ==1){\n                  means <- data.frame(rowMeans(matrix[,group==u[1]]))\n                }\n                else{\n                  means <- cbind(means, rowMeans(matrix[,group==u[i]]))\n                }\n              }\n              matrix <- as.matrix(means)\n              colnames(matrix) <- u\n            } else if(input$cctype == \"By Batch\"){\n              batch <- pEL$targets$batch\n              \n              u <- unique(batch)\n              for(i in 1:length(u)){\n                if(i==1){\n                  means <- data.frame(rowMeans(matrix[,batch==u[1]]))\n                }\n                else{\n                  means <- cbind(means, rowMeans(matrix[,batch==u[i]]))\n                }\n              }\n              matrix <- as.matrix(means)\n              colnames(matrix) <- u\n            }\n            \n            incProgress(0.25, detail = \"Calculating correlation coefficients\")\n            corA <- cor(matrix, method = tolower(input$CCcalcType))\n            cor.m <- melt(corA)\n            \n            incProgress(0.25, detail = \"Adjusting matrix\")\n            if(input$cctype == \"By Group\"){\n              cor.m$X1 <- rep(unique(group), ncol(matrix))\n              \n              X2 <- numeric()\n              \n              for(i in 1:ncol(matrix)){\n                X2 <- c(X2, rep(unique(group)[i], ncol(matrix)))\n              }\n              cor.m$X2 <- X2\n            }\n            else if(input$cctype == \"By Batch\"){\n              cor.m$X1 <- rep(unique(batch), ncol(matrix))\n              \n              X2 <- character()\n              \n              for(i in 1:ncol(matrix)){\n                X2 <- c(X2, rep(unique(batch)[i], ncol(matrix)))\n              }\n              cor.m$X2 <- X2\n            }\n            else{\n              cor.m$X1 <- rep(1:ncol(matrix), ncol(matrix))\n              \n              X2 <- numeric()\n              \n              for(i in 1:ncol(matrix)){\n                X2 <- c(X2, rep(i, ncol(matrix)))\n              }\n              cor.m$X2 <- X2\n            }\n            incProgress(0.25, detail = \"Building plot\")\n            if(input$cctype == \"By Group\"){\n              p <- ggplot(cor.m, aes(x = factor(X2), y = factor(X1))) + geom_tile(aes(fill = value), colour = \"white\") + labs(x = \"Group\", y = \"Group\") \n            } else if(input$cctype == \"By Batch\"){\n              p <- ggplot(cor.m, aes(x = factor(X2), y = factor(X1))) + geom_tile(aes(fill = value), colour = \"white\") + labs(x = \"Batch\", y = \"Batch\") \n            } else{\n              p <- ggplot(cor.m, aes(x = X2, y = X1)) + geom_tile(aes(fill = value), colour = \"white\") + labs(x = \"Sample Number\", y = \"Sample Number\") \n            }\n            plotColor(p, discrete = FALSE, input = input$plotColors, rev = input$colorsRev)\n          })\n        } else if (input$plotType == \"Boxplot\") {\n          E <- rEL$E\n          withProgress(message = 'Generating raw boxplots', value = 0, {\n            t <- \"Raw Expression Distribution\"\n            if(input$sortBox == 'Sample Number'){\n              lab <- \"Sample Number\"\n              p <- plotOrderBoxplot(E = E, title = t, lab = lab, cont = TRUE)\n              print(p)\n            } else{\n              if(input$sortBox == 'Condition'){\n                lab <- \"Condition\"\n                ov <- rEL$targets$Condition\n              } else if(input$sortBox == 'Group'){\n                lab <- \"Group\"\n                ov <- rEL$targets$group\n              } else if(input$sortBox == 'Batch'){\n                lab <- \"Batch\"\n                ov <- rEL$targets$batch\n              }\n              p <- plotOrderBoxplot(orderVector = ov, E = E, title = t, lab = lab)\n              plotColor(p, n = length(unique(ov)), input = input$plotColors, rev = input$colorsRev)\n            }\n          })\n        } else{\n          return(NULL)\n        }\n      } else{\n        return(NULL)\n      })\n  })\n  \n  #render plot of mirnas post processing\n  output$lowerQCPlot <- renderPlot({\n    #dont plot until button has been pushed\n    if (input$plotQC==0) {\n      return(NULL)\n    }\n    isolate(if (!is.null(processedElist())) {\n      pEL <- processedElist()\n      \n      if(!is.null(storageValues$svaE)){\n        pEL$E <- storageValues$svaE\n      }\n      \n      if (input$plotType == \"PCA Plot\") {\n        return(NULL)\n      } else if (input$plotType == \"Correlation Coefficient Matrix\") {\n        return(NULL)\n      } else if (input$plotType == \"Boxplot\") {\n        withProgress(message = 'Generating normalized boxplots', value = 0, {\n          t <- \"Normalized Expression Distribution\"\n          E <- pEL$E\n          if(input$sortBox == 'Sample Number'){\n            lab <- \"Sample Number\"\n            p <- plotOrderBoxplot(E = E, title = t, lab = lab, cont = TRUE)\n            print(p)\n          } else {\n            if(input$sortBox == 'Condition'){\n              lab <- \"Condition\"\n              ov <- pEL$targets$Condition\n            } else if(input$sortBox == 'Group'){\n              lab <- \"Group\"\n              ov <- pEL$targets$group\n            } else if(input$sortBox == 'Batch'){\n              lab <- \"Batch\"\n              ov <- pEL$targets$batch\n            }\n            p <- plotOrderBoxplot(orderVector = ov, E = E, title = t, lab = lab)\n            plotColor(p, n = length(unique(ov)), input = input$plotColors,  rev = input$colorsRev)\n          }  \n        })\n      } else{\n        return(NULL)\n      }\n    } else{\n      return(NULL)\n    })\n  })\n  \n  output$MAPlot <- renderPlotly({\n    if(!is.null(topTableList())){\n      if(is.null(input$condition1)){\n        return(NULL)\n      }\n      if(is.null(input$condition2)){\n        return(NULL)\n      }\n      withProgress(message = 'Generating MA plot', value = 0, {\n        incProgress(0.333, detail = \"Getting DE values\")\n        mirlist <- topTableList()\n        incProgress(0.333, detail = \"Generating thresholds\")\n        mirlist$threshold = as.factor(mirlist$AveExpr > input$AveEcut)\n        \n        incProgress(0.333, detail = \"Plotting MA Values\")\n        MAplot <-\n          ggplotly(ggplot(mirlist, aes(\n            x = AveExpr,\n            y = logFC,\n            colour = threshold\n          )) + geom_point(alpha = 0.75, size = 2, shape = 1) +\n          theme(legend.position = \"none\") +\n          ylab(\"M (Log2FC)\") + xlab(\"A (Average Expression)\") +\n          ggtitle(\"M vs A (Log2FC vs. Average Expression)\") +\n          scale_color_manual(values = c(\"#8c8c8c\", \"#ff0000\")) +\n          geom_vline(xintercept = input$AveEcut, color = \"Red\"))\n      })\n      return(MAplot)\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  #create volcano plot\n  output$volcanoPlot <- renderPlotly({\n    if(!is.null(topTableList())){\n      if(is.null(input$condition1)){\n        return(NULL)\n      }\n      if(is.null(input$condition2)){\n        return(NULL)\n      }\n      withProgress(message = 'Generating volcano plot', value = 0, {\n        incProgress(0.333, detail = \"Getting DE values\")\n        mirlist <- topTableList()\n        incProgress(0.333, detail = \"Generating thresholds\")\n        mirlist$threshold = as.factor(abs(mirlist$logFC) > log2(input$logFCcut) & mirlist$P.Value < 0.05 & mirlist$AveExpr > input$AveEcut)\n        \n        incProgress(0.333, detail = \"Plotting features\")\n        vplot <-\n          ggplotly(ggplot(mirlist, aes(\n            x = logFC,\n            y = -log10(P.Value),\n            colour = threshold\n          )) + geom_point(alpha = 0.75, size = 2, shape = 1) +\n          theme(legend.position = \"none\") +\n          xlim(c(-5, 5)) + ylim(c(0, 15)) +\n          xlab(\"log2(fold change)\") + ylab(\"-log10(p-value)\") +\n          ggtitle(\"P-Value vs Log2FC\") +\n          scale_color_manual(values = c(\"#8c8c8c\", \"#ff0000\")) +\n          geom_vline(xintercept = log2(input$logFCcut), color = \"Red\") +\n          geom_vline(xintercept = -log2(input$logFCcut), color = \"Red\") +\n          geom_abline(intercept = -log10(input$pValCut), slope = 0, color = \"Red\")) \n      })\n      return(vplot)\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  #WHAT IS THIS?\n  \n  output$heatmap <- renderPlot({\n    if(!is.null(topTableList())){\n      \n      if(is.null(input$condition1)){\n        return(NULL)\n      }\n      if(is.null(input$condition2)){\n        return(NULL)\n      }\n      \n      withProgress(message = 'Generating heatmap', value = 0, {\n        incProgress(0.25, detail = \"Getting DE values\")\n        mirlist <- topTableList()\n        elist <- processedElist()\n        incProgress(0.2, detail = \"Removing low values\")\n        #sig represents which elements of the list are eligible\n        sig <-\n          (mirlist$P.Value < input$pValCut &\n             abs(mirlist$logFC) > log2(input$logFCcut) & mirlist$AveExpr > input$AveEcut)\n        \n        storageValues$sig <- sig\n        \n        \n        sig_mir_list <- mirlist[sig,]\n        storageValues$sigMirs <- sig_mir_list$SystematicName\n        \n        \n        heatmap_match <-\n          match(elist$genes$ProbeName, sig_mir_list$ProbeName, nomatch = NA)\n        heatmap_elist <- elist[!is.na(heatmap_match),]\n        heatmap_elist = heatmap_elist[order(heatmap_match[!is.na(heatmap_match)]),] #sorts by the table\n        heatmap_elist = heatmap_elist[,order(heatmap_elist$targets$Condition)] #arranges columns by condition\n        incProgress(0.2, detail = \"Applying row transform\")\n        topMatrix <- t(scale(t(heatmap_elist$E)))\n        topMatrix[topMatrix < -3] <- -3\n        topMatrix[topMatrix > 3] <- 3\n        storageValues$topMatrix <- topMatrix\n        print(\"Storage Values:\")\n        print(names(storageValues))\n        \n        #insufficient DE features\n        if(nrow(topMatrix) * ncol(topMatrix) < 4){\n          return(NULL)\n        }\n        \n        rownames(topMatrix) <- heatmap_elist$genes$SystematicName\n        colnames(topMatrix) <- heatmap_elist$targets$FileName\n        \n        storageValues$hmMatrix <- topMatrix\n        \n        Condition <- heatmap_elist$targets$Condition\n        annotation <- data.frame(Condition)\n        \n        storageValues$annotation <- Condition\n        \n        incProgress(0.2, detail = \"Building heatmap\")\n        if(input$dendClust==0){\n          rv <- NA\n          cv <- NA\n        } else if(input$dendClust==1){\n          rv <- TRUE\n          cv <- NA\n        } else{\n          rv <- TRUE\n          cv <- TRUE\n        }\n        \n        a <-\n          aheatmap(\n            topMatrix,\n            col = heatmapPal(input$hmColors, input$hmRev),\n            Rowv = rv,\n            Colv = cv,\n            scale = \"none\",\n            annCol = annotation,\n            annColors = list(rainbow(length(unique(Condition))))\n          )\n        incProgress(0.2, detail = \"Applying annotation\")\n        storageValues$rowInd <- a$rowInd\n        storageValues$colInd <- a$colInd\n      })\n      return(a)\n    }else{\n      return(NULL)\n    }\n    \n  })\n  \n  output$sigMirTable <- renderTable({\n    if(!is.null(topTableList())){\n      mirlist <- topTableList()\n      sig <-\n        (mirlist$P.Value < (input$pValCut) &\n           abs(mirlist$logFC) > log2(input$logFCcut) & mirlist$AveExpr > input$AveEcut)\n      reg <-\n        data.frame(mirlist[sig, c(\"SystematicName\",\"logFC\",\"AveExpr\",\"t\",\"P.Value\",\"adj.P.Val\",\"B\")])\n      colnames(reg) <-\n        c(            \n          \"Systematic Name\",\n          \"Log2 Fold Change\",\n          \"Average Expression\",\n          \"t-value\",\n          \"P-value\",\n          \"Adjusted P-value (q)\",            \n          \"Log Odds (B)\"\n        )\n      return(reg)\n    } else{\n      return(NULL)\n    }\n  }, digits = 5, caption = \"<b><h4>Differentially Expressed miRNAs</h4></b>\", caption.placement = getOption(\"xtable.caption.placement\", \"top\"),\n  caption.width = getOption(\"xtable.caption.width\", NULL))\n  \n  heatmapFile <- reactive({\n    E <- storageValues$hmMatrix\n    Condition <- storageValues$annotation\n    anno <- data.frame(Condition)\n    \n    \n    if(is.null(E) || is.null(anno)){\n      return(NULL)\n    }\n    if(nrow(E) * ncol(E) < 4){\n      return(NULL)\n    }\n    \n    if(input$dendClust==0){\n      rv <- NA\n      cv <- NA\n    } else if(input$dendClust==1){\n      rv <- NA\n      cv <- TRUE\n    } else{\n      rv <- TRUE\n      cv <- TRUE\n    }\n    \n    #annotated heatmap\n    \n    a <-\n      aheatmap(\n        E,\n        col = heatmapPal(input$hmColors, input$hmRev),\n        Rowv = rv,\n        Colv = cv,\n        scale = \"none\",\n        annCol = anno,\n        annColors = list(rainbow(length(unique(Condition))))\n      )\n    return(a)\n  })\n  \n  heatmapMatrixFile <- reactive({\n    E <- storageValues$topMatrix\n    rowInd <- storageValues$rowInd\n    colInd <- storageValues$colInd\n    if(is.null(rowInd)){\n      rowInd <- TRUE\n    }\n    if(is.null(colInd)){\n      colInd <- TRUE\n    }\n    heatmapMatrixFile <- t(scale(t(E[rev(rowInd),colInd])))\n    return(heatmapMatrixFile)\n  })\n  \n  DeTableFile <- reactive({\n    mirlist <- topTableList()\n    sig <-\n      (mirlist$P.Value < (input$pValCut) &\n         abs(mirlist$logFC) > log2(input$logFCcut) & mirlist$AveExpr > input$AveEcut)\n    reg <-\n      data.frame(\n        mirlist[sig, c(\"SystematicName\",\"logFC\",\"AveExpr\",\"t\",\"P.Value\",\"adj.P.Val\",\"B\")])\n    colnames(reg) <-\n      c(\n        \"Systematic Name\",\n        \"Log2 Fold Change\",\n        \"Average Expression\",\n        \"t-value\",\n        \"P-value\",\n        \"Adjusted P-value (q)\",\n        \"Log Odds (B)\"\n      )\n    row.names(reg) <- NULL\n    return(reg)\n  })\n  FullTableFile <- reactive({\n    normEL <- storageValues$noFiltElist\n    \n    #create contrast string\n    contrast <-\n      paste(input$condition2, \"-\", input$condition1, sep = \"\")\n    \n    #design model matrix\n    f <- factor(normEL$targets$Condition, levels = unique(normEL$targets$Condition))\n    design <- model.matrix(~0 + f)\n    colnames(design) <- levels(f)\n    \n    #make lmfit\n    fit <- lmFit(normEL, design)\n    cont.matrix <- makeContrasts(contrasts = contrast, levels = design)\n    secondfit <- contrasts.fit(fit, cont.matrix)\n    secondfit <- eBayes(secondfit)\n    \n    #create top table for mir expression\n    mirlist <-\n      topTable(\n        secondfit,\n        adjust = \"BH\",\n        coef = 1,\n        number = 10000,\n        sort.by = \"logFC\"\n      )\n    reg <-\n      data.frame(\n        mirlist[, c(\"SystematicName\",\"logFC\",\"AveExpr\",\"t\",\"P.Value\",\"adj.P.Val\",\"B\")])\n    \n    colnames(reg) <-\n      c(\n        \"Systematic Name\",\n        \"Log2 Fold Change\",\n        \"Average Expression\",\n        \"t-value\",\n        \"P-value\",\n        \"Adjusted P-value (q)\",\n        \"Log Odds (B)\"\n      )\n    row.names(reg) <- NULL\n    return(reg)\n  })\n  \n  #  #  #  #  #  #  #  #  #  #  #  #  #  #\n  \n  output$subsetUI <- renderUI({\n    if (!is.null(rawElist()$targets$group)) {\n      groups <- unique(rawElist()$targets$group)\n      ordGroups <- groups[order(groups)]\n      selectInput(\n        inputId = \"subsetGrps\",\n        label = NULL,\n        multiple = TRUE,\n        choices = ordGroups,\n        selected = ordGroups\n      )\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  subsetVector <- reactive({\n    if (!is.null(rawElist()$targets$group)) {\n      groupVector <- rawElist()$targets$group\n      subVector <- groupVector %in% input$subsetGrps\n      if(sum(subVector) == 0) subVector <- rep(TRUE, length(groupVector))\n      return(subVector)\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  output$trGrpsUI <- renderUI({\n    if (!is.null(rawElist()$targets$group)) {\n      groups <- unique(rawElist()$targets$group)\n      ordGroups <- groups[order(groups)]\n      selectInput(\n        inputId = \"trGrps\",\n        label = \"Groups To Recenter\",\n        multiple = TRUE,\n        choices = ordGroups,\n        selected = NULL\n      )\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  output$housekeepUI <- renderUI({\n    if (!is.null(rawElist())) {\n      hk <- rowSums(rawElist()$E)\n      names(hk) <- row.names(rawElist()$E)\n      hk <-\n        hk[order(hk, decreasing = TRUE)]\n      \n      #pick top 20 high expressed microRNAs\n      hk <- hk[1:20]\n      hk <- names(hk)\n      \n      if (!is.null(rawElist()$targets$normalizer)){\n        hk <-\n          c(hk, \"Custom vector (\\\"normalizer\\\")\")\n      }\n      selectInput(inputId = \"housekeep\",\n                  label = \"Housekeeping Gene (ranked by expression)\",\n                  choices = hk)\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  output$filtPercent <- renderUI({\n    rEL <- rawElist()\n    if (!is.null(rEL$targets$group)) {\n      rEL <- rEL[, subsetVector()]\n    }\n    val <- 50\n    if (!is.null(rawElist())) {\n      #find 1 sample value\n      val <- round(100 / (ncol(rEL$E) + 1), 2)\n    }\n    fp <- numericInput(\n      inputId = \"filtPercent\",\n      label = \"Sample % Threshold\",\n      min = 0,\n      max = 100,\n      value = val,\n      step = 0.1\n    )\n    \n    return(fp)\n  })\n  \n  output$filtSampleNumber <- renderText({\n    if (!is.null(rawElist())) {\n      rEL <- rawElist()\n      if (!is.null(rEL$targets$group)) {\n        rEL <- rEL[, subsetVector()]\n      }\n      print(ceiling(ncol(rEL$E) * (input$filtPercent %% 100) / 100)) #this print statement is important for some reason\n    }\n    else{\n      print(\"-\")\n    }\n  })\n  \n  output$upperPlotUI <- renderUI({\n    input$plotQC\n    #defaults\n    w <- 1000\n    h <- 400\n    isolate(\n      if(input$plotType == 'PCA Plot'){\n        w <- 950\n        h <- 1000\n      }\n      else if(input$plotType == 'Correlation Coefficient Matrix'){\n        w <- 950\n        h <- 950\n      }\n      else if(input$plotType == 'Boxplot'){\n        w <- '100%'\n        h <- 450\n      }\n    )\n    plotOutput(\"upperQCPlot\", width = w, height = h)\n  })\n  \n  output$lowerPlotUI <- renderUI({\n    input$plotQC\n    if(input$plotType == 'Boxplot'){\n      w <- '100%'\n      h <- 450\n    }else{\n      return(NULL)\n    }\n    plotOutput(\"lowerQCPlot\", width = w, height = h)\n  })\n  \n  output$sortBoxplotUI <- renderUI({\n    rEL <- rawElist()\n    choices <- c(\"Sample Number\", \"Condition\")\n    if(!is.null(rEL$targets$group)){\n      choices <- c(choices, \"Group\")\n    }\n    if(!is.null(rEL$targets$batch)){\n      choices <- c(choices, \"Batch\")\n    }\n    selectInput(\n      inputId = \"sortBox\",\n      label = \"Order Samples by:\",\n      choices = choices,\n      selected = choices[1]\n    )\n  })\n  \n  output$PCAtypeUI <- renderUI({\n    rEL <- rawElist()\n    choices <- c(\"PC1/PC2\", \"PC1/PC2 with K-means\", \"PC1/PC2/PC3\", \"Facet by Condition\")\n    if(!is.null(rEL$targets$group)){\n      choices <- c(choices, \"Facet by Group\")\n    }\n    if(!is.null(rEL$targets$batch)){\n      choices <- c(choices, \"Facet by Batch\")\n    }\n    selectInput(\n      inputId = \"pcaType\",\n      label = \"PCA Plot Display Options\",\n      choices = choices,\n      selected = choices[1]\n    )\n  })\n  \n  output$sortPCAUI <- renderUI({\n    rEL <- rawElist()\n    choices <- c(\"Condition\")\n    if(!is.null(rEL$targets$group)){\n      choices <- c(choices, \"Group\")\n    }\n    if(!is.null(rEL$targets$batch)){\n      choices <- c(choices, \"Batch\")\n    }\n    selectInput(\n      inputId = \"sortPCA\",\n      label = \"PCA Plot Grouping Options\",\n      choices = choices,\n      selected = choices[1]\n    )\n  })\n  \n  output$CCtypeUI <- renderUI({\n    rEL <- rawElist()\n    choices <- c(\"By Sample\")\n    if(!is.null(rEL$targets$group)){\n      choices <- c(choices, \"By Group\")\n    }\n    if(!is.null(rEL$targets$batch)){\n      choices <- c(choices, \"By Batch\")\n    }\n    selectInput(\n      inputId = \"cctype\",\n      label = \"CC Matrix Display Options\",\n      choices = choices,\n      selected = choices[1]\n    )\n  })\n  \n  output$condition1UI <- renderUI({\n    rEL <- rawElist()\n    c <- unique(sapply(X = rEL$targets$Condition, FUN = toString))\n    selectInput(\n      inputId = \"condition1\",\n      multiple = TRUE,\n      label = \"Control group\",\n      choices = c,\n      selected = c[1]\n    )\n  })\n  \n  output$condition2UI <- renderUI({\n    rEL <- rawElist()\n    c <- unique(sapply(X = rEL$targets$Condition, FUN = toString))\n    selectInput(\n      inputId = \"condition2\",\n      multiple = TRUE,\n      label = \"Patient group\",\n      choices = c,\n      selected = c[2]\n    )\n  })\n  \n  # output$heatmapUI <- renderUI({\n  #   if(!is.null(processedElist())&&!is.null(topTableList())){\n  #     \n  #     mirlist <- topTableList()\n  #     elist <- processedElist()\n  #     sig <-\n  #       (mirlist$P.Value < input$pValCut &\n  #          abs(mirlist$logFC) > log2(input$logFCcut) & mirlist$AveExpr > input$AveEcut)\n  #     \n  #     sig_mirlist <- mirlist[sig,]\n  #     \n  #     col <- ncol(elist$E)\n  #     row <- nrow(sig_mirlist)\n  #     \n  #     w <- '100%'\n  #     h <- 700\n  #     \n  #     ratio <- col / row\n  #     if(ratio < 4) ratio <- 4\n  #     if(ratio > 16) ratio <- 16\n  #     ratio <- log2(ratio)\n  #     \n  #     h <- 700 - 175 * (ratio-2)\n  #     \n  #     if(col <30){\n  #       scale <- 0.4 + 0.02 * col\n  #       h <- scale * h\n  #       w <- paste0(100 * scale, '%')\n  #     }\n  #     storageValues$hmW <- w\n  #     storageValues$hmH <- h\n  #     return(plotOutput(\"heatmap\", width = w, height = h))\n  #   }\n  #   else{\n  #     return(NULL)\n  #   }\n  # })\n  \n  # Working Test Implementation of heatmaply:\n  \n  # output$heatmapUI <- renderPlotly({\n  #   heatmaply(mtcars, xlab = \"Features\", ylab = \"Cars\",\n  #             margins = c(60,100,40,20))\n  # })\n  \n  # Try to link to EList:\n  \n  output$heatmapUI <- renderPlotly({\n    #mirlist <- topTableList()\n    #print(mirlist)\n    \n    if(!is.null(processedElist())&&!is.null(topTableList())){\n      mirlist <- topTableList()\n        elist <- processedElist()\n        sig <-\n          (mirlist$P.Value < input$pValCut &\n             abs(mirlist$logFC) > log2(input$logFCcut) & mirlist$AveExpr > input$AveEcut)\n\n        sig_mirlist <- mirlist[sig,]\n        print(\"This is mirlist:\")\n        print(mirlist)\n        print(\"This is sig_mirlist:\")\n        print(sig_mirlist)\n        print(\"storage values hmMatrix:\")\n        print(storageValues$hmMatrix)\n          col <- ncol(elist$E)\n          row <- nrow(sig_mirlist)\n          \n          #\n          incProgress(0.25, detail = \"Getting DE values\")\n          mirlist <- topTableList()\n          elist <- processedElist()\n          incProgress(0.2, detail = \"Removing low values\")\n          #sig represents which elements of the list are eligible\n          sig <-\n            (mirlist$P.Value < input$pValCut &\n               abs(mirlist$logFC) > log2(input$logFCcut) & mirlist$AveExpr > input$AveEcut)\n          \n          storageValues$sig <- sig\n          \n          \n          sig_mir_list <- mirlist[sig,]\n          storageValues$sigMirs <- sig_mir_list$SystematicName\n          \n          \n          heatmap_match <-\n            match(elist$genes$ProbeName, sig_mir_list$ProbeName, nomatch = NA)\n          heatmap_elist <- elist[!is.na(heatmap_match),]\n          heatmap_elist = heatmap_elist[order(heatmap_match[!is.na(heatmap_match)]),] #sorts by the table\n          heatmap_elist = heatmap_elist[,order(heatmap_elist$targets$Condition)] #arranges columns by condition\n          incProgress(0.2, detail = \"Applying row transform\")\n          topMatrix <- t(scale(t(heatmap_elist$E)))\n          topMatrix[topMatrix < -3] <- -3\n          topMatrix[topMatrix > 3] <- 3\n          storageValues$topMatrix <- topMatrix\n          print(\"Storage Values:\")\n          print(names(storageValues))\n          \n          #insufficient DE features\n          if(nrow(topMatrix) * ncol(topMatrix) < 4){\n            return(NULL)\n          }\n          \n          rownames(topMatrix) <- heatmap_elist$genes$SystematicName\n          colnames(topMatrix) <- heatmap_elist$targets$FileName\n          \n          storageValues$hmMatrix <- topMatrix\n          #\n    }\n    \n    heatmaply({ #HERE\n        # if(!is.null(processedElist())&&!is.null(topTableList())){\n        # \n        #   mirlist <- topTableList()\n        #   elist <- processedElist()\n        #   sig <-\n        #     (mirlist$P.Value < input$pValCut &\n        #        abs(mirlist$logFC) > log2(input$logFCcut) & mirlist$AveExpr > input$AveEcut)\n        # \n        #   sig_mirlist <- mirlist[sig,]\n        # \n        #   col <- ncol(elist$E)\n        #   row <- nrow(sig_mirlist)\n        # \n        #   w <- '100%'\n        #   h <- 700\n        # \n        #   ratio <- col / row\n        #   if(ratio < 4) ratio <- 4\n        #   if(ratio > 16) ratio <- 16\n        #   ratio <- log2(ratio)\n        # \n        #   h <- 700 - 175 * (ratio-2)\n        # \n        #   if(col <30){\n        #     scale <- 0.4 + 0.02 * col\n        #     h <- scale * h\n        #     w <- paste0(100 * scale, '%')\n        #   }\n        #   storageValues$hmW <- w\n        #   storageValues$hmH <- h\n        #   #don't return, just declare matrix\n        #   #return(plotOutput(\"heatmap\", width = w, height = h))\n        # }\n        # else{\n        #   return(NULL)\n        # }\n\n      #TO HERE\n      \n      #processedElist\n      #topTableList\n      topMatrix\n    })\n  })\n  \n  output$downloadHM <- downloadHandler(\n    filename = function() {\n      paste(input$hmImageName, '.png', sep = '')\n    },\n    content = function(file) {\n      png(file, width = 3.5*storageValues$hmH, height = 2*storageValues$hmH)\n      print(heatmapFile())\n      dev.off()\n    }\n  )\n  output$downloadMatrix <- downloadHandler(\n    filename = function() {\n      paste(input$hmName, '.csv', sep = '')\n    },\n    content = function(file) {\n      write.csv(heatmapMatrixFile(), file)\n    }\n  )\n  output$downloadDETab <- downloadHandler(\n    filename = function() {\n      paste(input$deName, '.csv', sep = '')\n    },\n    content = function(file) {\n      write.csv(DeTableFile(), file)\n    }\n  )\n  output$downloadFullTab <- downloadHandler(\n    filename = function() {\n      paste(input$fullName, '.csv', sep = '')\n    },\n    content = function(file) {\n      write.csv(FullTableFile(), file)\n    }\n  )\n  output$dataExists <- reactive({\n    return(!is.null(rawElist()))\n  })\n  outputOptions(output, 'dataExists', suspendWhenHidden = FALSE)\n  output$groupExists <- reactive({\n    return(!is.null(rawElist()$targets$group))\n  })\n  outputOptions(output, 'groupExists', suspendWhenHidden = FALSE)\n  \n  output$batchExists <- reactive({\n    return(!is.null(rawElist()$targets$batch))\n  })\n  outputOptions(output, 'batchExists', suspendWhenHidden = FALSE)\n  output$sigMirsExist <- reactive({\n    return(!is.null(storageValues$sigMirs) && length(storageValues$sigMirs) > 0)\n  })\n  outputOptions(output, 'sigMirsExist', suspendWhenHidden = FALSE)\n  \n  output$deSelectUI <- renderUI({\n    sigMirs <- storageValues$sigMirs\n    selectInput(\n      inputId = \"sigMir\",\n      label = \"Select miRNAs to view\",\n      choices = sigMirs,\n      selected = sigMirs[1],\n      multiple = TRUE\n    )\n  })\n  output$singleMirBoxplot <- renderPlot({\n    input$plotDE\n    isolate(\n      if(!is.null(input$sigMir)){\n        withProgress(message = 'Generating boxplots', value = 0, {\n          selected <- input$sigMir\n          pEL <- processedElist()\n          incProgress(0.1, detail = \"Getting expression values\")\n          \n          condition <- rep(pEL$targets$Condition, length(selected))\n          \n          incProgress(0.1, detail = \"Subsetting dataset\")\n          values <- vector()\n          for(i in 1: length(selected)){\n            values <- c(values, pEL$E[selected[i],])\n          }\n          \n          sample <- vector()\n          for(i in 1:length(selected)){\n            sample <- c(sample, rep(selected[i], ncol(pEL)))\n          }\n          \n          incProgress(0.4, detail = \"Building plot\")\n          bpDF <- data.frame(condition, values, sample)\n          if(input$dePlotType == \"Boxplot\"){\n            p <- ggplot(bpDF, aes(x = condition, y = values, fill = factor(condition))) + geom_boxplot(outlier.shape = 3, outlier.color = '#ff0000', width = 0.65, outlier.size = 1, outlier.alpha = 0.2, notch = input$deNotch) + xlab(\"Condition\") + ylab(\"Normalized Expression Value\") + labs(fill = \"Condition\")\n            if(input$deDot){\n              p <- p + geom_dotplot(binaxis = \"y\", stackdir = \"centerwhole\", fill = \"White\", dotsize = 0.65)\n            }\n          } else {\n            #Violin Plot\n            p <- ggplot(bpDF, aes(x = condition, y = values, fill = factor(condition))) + geom_violin() + xlab(\"Condition\") + ylab(\"Normalized Expression Value\") + labs(fill = \"Condition\")\n            if(input$deBox){\n              p <- p + geom_boxplot(width = 0.1, fill = \"White\")\n            }\n          }\n          incProgress(0.4, detail = \"Applying facets \")\n          plotColor(p+facet_wrap(~sample, scales = \"free\", ncol = ceiling(sqrt(length(selected)))) + theme(axis.title=element_text(size=14), axis.text=element_text(size=12)), input = input$miRplotColors, rev = input$miRcolorsRev, n = length(unique(condition)))\n        })\n      }\n      else{\n        return(NULL)\n      }\n    )\n  })\n  \n  output$idealProfileTable <- renderTable({\n    input$idealButton\n    isolate(\n      if(!is.null(input$idealProfile) && !is.null(rawElist())){\n        withProgress(message = \"Calculating correlation\", value = 0, {\n          incProgress(0.25, detail = \"Reading values\")\n          idealProfile <- read.csv(file = win(input$idealProfile$datapath), header = TRUE, check.names = FALSE)\n          if(ncol(idealProfile > 5)){\n            idealProfile <- idealProfile[,1:5]\n          }\n          incProgress(0.25, detail = \"Cleaning data\")\n          idealProfile[is.na(idealProfile)] <- 0\n          idealProfile[is.null(idealProfile)] <- 0\n          idealProfile[idealProfile < 0] <- 0\n          fullE <- rawElist()$E\n          if(nrow(fullE) == nrow(idealProfile)){\n            incProgress(0.25, detail = \"Calculating values\")\n            cor.m <- cor(fullE, idealProfile, method = tolower(input$idealCorrType))\n            avg <- colMeans(cor.m)\n            rms <- colSums(((cor.m - 1) ^ 2))\n            m <- rbind(avg, rms, cor.m)\n            incProgress(0.25, detail = \"Binding data\")\n            sNames <- c(\"Average\", \"RMS.Error\", colnames(fullE))\n            colnames(m) <- colnames(idealProfile)\n            row.names(m) <- sNames\n            return(m)\n          } else{\n            return(NULL)\n          }\n        })\n      } else {\n        return(NULL)\n      }\n    )\n  }, rownames = TRUE)\n  \n  observeEvent(input$powerPlotButton, {\n    \n    if(is.null(storageValues$powerCurves)) {\n      storageValues$powerCurves = list(5)\n      storageValues$numPowerCurves = 0\n    }\n    if(is.null(storageValues$powerTables)) {\n      storageValues$powerTables = list(5)\n    }\n    \n    withProgress(message = \"Setting parameters\", value = 0, {\n      #default values\n      samplesize = input$powerSampleSize\n      foldchange = input$powerFoldChange\n      fdr = input$powerFDR\n      averagereadcounts = input$powerAverageReadCounts\n      maxdispersion = input$powerMaxDispersion\n      featurecount = input$powerFeatureCount\n      prognosticfeaturecount = input$powerPrognosticFeatureCount\n      dataMatrixDistribution = NULL\n      repNumber = 1\n      #if user wants, we set above variables based on calculations of uploaded data\n      if(input$powerUseData) {\n        setProgress(0.2, message = \"Calculating other parameters\")\n        featurecount = nrow(rawElist())\n        if(input$powerUseCutoff) { #use differentially expressed mirna\n          mirList = topTableList()\n          sigmirs = mirList[storageValues$sig,]\n          prognosticfeaturecount = nrow(sigmirs)\n          foldchange = 2 ^ min(abs(sigmirs$logFC))\n          fdr = max(sigmirs$adj.P.Val)\n        }\n        #get the distribution object from the raw elist, even if user uses DE mirna\n        #produces an NA if there is no replication\n        dataMatrixDistribution = est_count_dispersion(rawElist()$E,\n                                                      group = rawElist()$targets$group, minAveCount = 0, subSampleNum = 100)\n        if(!is.na(dataMatrixDistribution$common.dispersion)) {\n          #only used to print out parameters in the table\n          maxdispersion = \"NA\"\n        } else {\n          showModal(modalDialog(\n            title = \"Error Calculating Parameters\",\n            \"Uploaded data has no replications, cannot make statistical inferences from data.\"\n          ))\n          return(NULL)\n        }\n        #only used to print out parameters in the table\n        averagereadcounts = \"NA\"\n        #only use data points with read counts >= 5\n        if(length(which(dataMatrixDistribution$pseudo.counts.mean >= 5)) < input$powerRepNumber) {\n          showModal(modalDialog(\n            title = \"Warning Calculating Parameters\",\n            paste(\"Estimation repetition count too high for this data, lowering to\", length(which(dataMatrixDistribution$pseudo.counts.mean >= 5)))\n          ))\n          repNumber = length(which(dataMatrixDistribution$pseudo.counts.mean >= 5))\n        } else {\n          repNumber = input$powerRepNumber\n        }\n      }\n      if(input$powerPlotType == \"Sample size\"){\n        setProgress(0.5, message = \"Calculating power\")\n        #can only display 5\n        storageValues$powerCurves[[(storageValues$numPowerCurves %% 5) + 1]] = est_power_curve_better(\n          n = samplesize, f = fdr, rho = foldchange, lambda0 = averagereadcounts, phi0 = maxdispersion, m = featurecount, m1 = prognosticfeaturecount,\n          stepsize = input$powerStepInterval, squarestep = (input$powerPlotChoice == \"Squared intervals\"), usegradient = (input$powerPlotChoice == \"Gradient-sensitive intervals\"), gradientdetail = input$powerGradientDetail,\n          distributionObject = dataMatrixDistribution,repNumber = repNumber)\n        #store these paramters to display later\n        storageValues$powerCurves[[(storageValues$numPowerCurves %% 5) + 1]]$parameters[\"m\"] = featurecount\n        storageValues$powerCurves[[(storageValues$numPowerCurves %% 5) + 1]]$parameters[\"m1\"] = prognosticfeaturecount\n      } else if(input$powerPlotType == \"Power\"){\n        setProgress(0.5, message = \"Calculating sample size\")\n        desiredpower = input$powerMaxPower\n        if(desiredpower >= 1) { #power can never be 1\n          desiredpower = 0.999\n        }\n        if(foldchange == 1) { #quik n dirty error handling\n          showModal(modalDialog(\n            title = \"Error Calculating Sample Size\",\n            \"No non-zero power for a fold change of 1\"\n          ))\n          return(NULL)\n        }\n        if(is.null(dataMatrixDistribution)) {\n          storageValues$powerCurves[[(storageValues$numPowerCurves %% 5) + 1]] = sample_size(power = desiredpower, f = fdr, rho = foldchange, lambda0 = averagereadcounts, phi0 = maxdispersion, m = featurecount, m1 = prognosticfeaturecount, storeProcess = T)\n        } else {\n          storageValues$powerCurves[[(storageValues$numPowerCurves %% 5) + 1]] = sample_size_distribution(power = desiredpower, f = fdr, rho = foldchange, distributionObject = dataMatrixDistribution, repNumber = repNumber, m = featurecount, m1 = prognosticfeaturecount, storeProcess = T)\n        }\n      }\n      #debug print\n      #print(storageValues$powerCurves[[(storageValues$numPowerCurves %% 5) + 1]])\n      setProgress(1, message = \"Plotting\")\n      #displays a table of #samples vs power\n      storageValues$powerTables[[(storageValues$numPowerCurves %% 5) + 1]] = \n        if(!is.null(storageValues$powerCurves[[(storageValues$numPowerCurves %% 5) + 1]])){\n          curve = storageValues$powerCurves[[(storageValues$numPowerCurves %% 5) + 1]]\n          reg = data.frame(curve$process[, c(\"N\",\"Power\")])\n          colnames(reg) =\n            c(            \n              \"Samples\",\n              \"Power\"\n            )\n          reg\n        } else{\n          NULL\n        }\n      storageValues$numPowerCurves = storageValues$numPowerCurves + 1\n    })\n  })\n  observeEvent(input$powerClearPlotButton, {\n    storageValues$powerCurves = NULL\n    storageValues$powerTables = NULL\n    storageValues$numPowerCurves = 0\n  })\n  \n  output$powerPlot = renderPlot({\n    if(!is.null(storageValues$powerCurves)) {\n      plot_power_curve_better(storageValues$powerCurves, las = 2, main = \"Sample Size vs. Statistical Power\")\n    }\n  })\n  #displays parameters of each graph\n  output$powerParameterTable = renderTable({\n    if(!is.null(storageValues$powerCurves)){\n      reg = data.frame(storageValues$powerCurves[[1]]$parameters[c(\"fdr\",\"rho\",\"lambda0\",\"phi0\", \"m\", \"m1\")])\n      if(length(storageValues$powerCurves) > 1) {\n        for(x in 2:length(storageValues$powerCurves)) {\n          reg = data.frame(reg, storageValues$powerCurves[[x]]$parameters[c(\"fdr\",\"rho\",\"lambda0\",\"phi0\", \"m\", \"m1\")])\n        }\n      }\n      \n      rownames(reg) <-\n        c(            \n          \"False Discovery Rate\",\n          \"Fold Change\",\n          \"Average Read Count\",\n          \"Dispersion\",\n          \"Total Number of miRNAs\",\n          \"Expected Number of DE miRNAs\"\n        )\n      colnames(reg) = paste(\"Power Graph\", 1:length(storageValues$powerCurves))\n      return(reg)\n    } else{\n      return(NULL)\n    }\n  }, digits = 3, caption = \"<b><h4>Parameter List</h4></b>\", caption.placement = getOption(\"xtable.caption.placement\", \"top\"),\n  rownames = T)\n  #THERE HAS TO BE A BETTER WAY\n  output$powerTable1 = renderTable(if(!is.null(storageValues$numPowerCurves) && storageValues$numPowerCurves > 0){storageValues$powerTables[[1]]}else{NULL}, digits = 3, caption = \"<b><h4>Power table 1</h4></b>\", caption.placement = getOption(\"xtable.caption.placement\", \"top\"),\n                                   caption.width = getOption(\"xtable.caption.width\", NULL))\n  output$powerTable2 = renderTable(if(!is.null(storageValues$numPowerCurves) && storageValues$numPowerCurves > 1){storageValues$powerTables[[2]]}else{NULL}, digits = 3, caption = \"<b><h4>Power table 2</h4></b>\", caption.placement = getOption(\"xtable.caption.placement\", \"top\"),\n                                   caption.width = getOption(\"xtable.caption.width\", NULL))\n  output$powerTable3 = renderTable(if(!is.null(storageValues$numPowerCurves) && storageValues$numPowerCurves > 2){storageValues$powerTables[[3]]}else{NULL}, digits = 3, caption = \"<b><h4>Power table 3</h4></b>\", caption.placement = getOption(\"xtable.caption.placement\", \"top\"),\n                                   caption.width = getOption(\"xtable.caption.width\", NULL))\n  output$powerTable4 = renderTable(if(!is.null(storageValues$numPowerCurves) && storageValues$numPowerCurves > 3){storageValues$powerTables[[4]]}else{NULL}, digits = 3, caption = \"<b><h4>Power table 4</h4></b>\", caption.placement = getOption(\"xtable.caption.placement\", \"top\"),\n                                   caption.width = getOption(\"xtable.caption.width\", NULL))\n  output$powerTable5 = renderTable(if(!is.null(storageValues$numPowerCurves) && storageValues$numPowerCurves > 4){storageValues$powerTables[[5]]}else{NULL}, digits = 3, caption = \"<b><h4>Power table 5</h4></b>\", caption.placement = getOption(\"xtable.caption.placement\", \"top\"),\n                                   caption.width = getOption(\"xtable.caption.width\", NULL))\n  \n  output$circularplot = renderPlot({\n    if(!is.null(topTableList())) {\n      withProgress(message = \"Mapping to Genome\", value = 0.1, {\n        #read file\n        #mblistfile = system.file(\"HGNC_miRBase_list(20160323)curated.xlsx\", package = \"openxlsx\")\n        mblist = read.xlsx(xlsxFile = \"HGNC_miRBase_list(20160323)curated.xlsx\", sheet = 1)\n        maplist = read.xlsx(xlsxFile = \"human_miRNA_name_mapping(2017-07-28).xlsx\", sheet = 1)\n        \n        #get names n vals\n        mirlist = topTableList()\n        start = regexpr(\":\", mirlist$SystematicName) + 1\n        names = substr(mirlist$SystematicName, start, 1000)\n        values = mirlist$logFC\n        expression = mirlist$AveExpr\n        sig = storageValues$sig\n        #map onto database\n        #TODO: get it to work with all name types, e.g. if it isn't under compatibleName, look in pre-miRNA\n        map_match = match(names, c(maplist$compatibleName, maplist$unifiedName), nomatch = NA) #do not put unique on this\n        map_match = (map_match - 1) %% nrow(maplist) + 1\n        mir_match = match(c(maplist$compatibleName, maplist$unifiedName), names, nomatch = NA)\n        for(i in seq(nrow(maplist), length(mir_match), by = 1)) { #collapse the excess rows\n          if(is.na(mir_match[i %% nrow(maplist) + 1]) && !is.na(mir_match[i + 1])) { #lmao 1 based indexing\n            mir_match[i %% nrow(maplist) + 1] = mir_match[i + 1]\n            #print(paste(\"replacing index\", i %% nrow(maplist) + 1,\"with value\",mir_match[i + 1]))\n          }\n        }\n        mir_match = mir_match[1:nrow(maplist)]\n        map_val = values[mir_match]\n        map_expr = expression[mir_match]\n        map_sig = sig[mir_match]\n        maplist = cbind(maplist, map_val, map_expr, map_sig) #attach vals to the maplist\n        map_use = maplist[map_match,]\n        \n        nmapped = nrow(map_use[!is.na(map_use[,\"pre-miRNA\"]),])\n        if(nmapped / nrow(mirlist) < 0.25) { #if less than 25% gets mapped\n          showModal(modalDialog(\n            title = \"Warning Mapping miRNAs to database\",\n            paste(\"Less than 25% of miRNAs successfully mapped\", nmapped, \"out of\", nrow(sig_mir_list), \"mapped\")\n          ))\n          \n        }\n        #map_match = match(mblist$\"miRBase.ID(s)\", map_use$\"pre-miRNA\", nomatch = NA)\n        mb_match = match(map_use$\"pre-miRNA\", mblist$\"miRBase.ID(s)\", nomatch = NA)\n        map_chr = mblist[mb_match, \"Chromosome\"] #map chromosome info from mirbaselist to maplist\n        map_gstart = mblist[mb_match, \"Gene.Start.(bp)\"]\n        map_gend = mblist[mb_match, \"Gene.End.(bp)\"]\n        map_use = cbind(map_use, map_chr, map_gstart, map_gend) #attach chromosome info\n        #mb_use = mblist[mb_match,]\n        \n        setProgress(value = 0.3, message = \"Preparing to graph\")\n        #prepare to graph\n        data = map_use[!is.na(map_use[,\"map_val\"]),c(\"map_chr\", \"map_gstart\",\"map_gend\",\"map_val\", \"map_expr\", \"map_sig\", \"unifiedName\")]\n        data[,\"map_chr\"] = paste(\"chr\", data[,\"map_chr\"], sep = \"\")\n        colnames(data) = c(\"chr\", \"start\", \"end\", \"foldchange\", \"averageexpression\", \"sig\", \"id\")\n        rownames(data) = 1:nrow(data)\n        data_sig = data[data[,\"sig\"],]\n        \n        circos.par(\"start.degree\" = 0, \"gap.degree\" = c(rep(5,8), 9, rep(5,14), 5),\n                   \"track.height\" = 0.15)\n        circos.initializeWithIdeogram(plotType = c(\"ideogram\", \"axis\", \"labels\"))\n        #a difference of 1000000 is barely enough to show up on screen\n        minwidth = 1200000\n        expressioncoefficient = 5 / max(data[,\"averageexpression\"]) #for calculating transparency\n        foldchangecoefficient = 2.5 / max(abs(data$foldchange))\n        circos.genomicTrackPlotRegion(data, ylim = c(0, 1), bg.border = NA, track.height = 0.15, panel.fun = function(region, value, ...) {\n          tempregion = cbind(region$start - minwidth, region$end + minwidth)\n          weight = 1 - 1 / (1 + value$averageexpression * expressioncoefficient)\n          ytop = rep(0.9, nrow(region))\n          ytop[value$sig] = 1.1\n          ybottom = rep(0.1, nrow(region))\n          ybottom[value$sig] = -0.1\n          circos.genomicRect(tempregion, ytop = ytop, ybottom = ybottom, col = rgb(0, 0.5, 0, alpha = weight), border = NA)\n          incProgress(amount = 0.35/nrow(data) * nrow(value), message = \"Graphing average expression\", detail = CELL_META$sector.index)\n        })\n        circos.text(CELL_META$xlim[1] - ux(3, \"mm\"), CELL_META$ycenter, labels = \"Avg. Expr.\", facing = \"downward\", sector.index = \"chr1\")\n        for(chr in unique(data_sig[,\"chr\"])) { #the text in the middle of the ave expr bars\n          data_sig_chr = data_sig[data_sig[,\"chr\"] == chr,]\n          data_sig_chr_region = data_sig_chr[,c(\"start\", \"end\")]\n          #yeah just trust this little piece of code below\n          circos.genomicText(data_sig_chr_region, NULL, 0.5 + uy(seq(-1.5 + nrow(data_sig_chr) * 1.5, 1.5 + nrow(data_sig_chr) * -1.5, length.out = nrow(data_sig_chr)),\"mm\"), labels = round(data_sig_chr[,\"averageexpression\"],2), cex = 0.85, facing = \"outside\", niceFacing = T, sector.index = chr)\n        }\n        circos.genomicTrackPlotRegion(data, ylim = c(0, 1), bg.border = NA, track.height = 0.15, panel.fun = function(region, value, ...) {\n          tempregion = cbind(region$start - minwidth, region$end + minwidth)\n          weight = 1 - 1 / (1 + abs(value$foldchange * foldchangecoefficient) ^ 2)\n          ytop = rep(0.9, nrow(region))\n          ytop[value$sig] = 1.1\n          ybottom = rep(0.1, nrow(region))\n          ybottom[value$sig] = -0.1\n          circos.genomicRect(tempregion, ytop = ytop, ybottom = ybottom, col = rgb(0.5, 0, 0, alpha = weight), border = NA)\n          incProgress(amount = 0.35/nrow(data) * nrow(value), message = \"Graphing foldchange\", detail = CELL_META$sector.index)\n        })\n        circos.text(CELL_META$xlim[1] - ux(3, \"mm\"), CELL_META$ycenter, labels = \"Fold Change\", facing = \"downward\", sector.index = \"chr1\")\n        for(chr in unique(data_sig[,\"chr\"])) { #text in the middle of the logfc bars and the miRNA ids\n          data_sig_chr = data_sig[data_sig[,\"chr\"] == chr,]\n          data_sig_chr_region = data_sig_chr[,c(\"start\", \"end\")]\n          circos.genomicText(data_sig_chr_region, NULL, 0.5 + uy(seq(-1.5 + nrow(data_sig_chr) * 1.5, 1.5 + nrow(data_sig_chr) * -1.5, length.out = nrow(data_sig_chr)),\"mm\"), labels = round(data_sig_chr[,\"foldchange\"],2), cex = 0.85, facing = \"outside\", niceFacing = T, sector.index = chr)\n          circos.genomicText(data_sig_chr_region, NULL, uy(seq(-3, nrow(data_sig_chr) * -3, length.out = nrow(data_sig_chr)),\"mm\"), labels = substr(data_sig_chr[,\"id\"], 5, 1000), cex = 0.85, facing = \"outside\", niceFacing = T, sector.index = chr)\n        }\n        circos.clear()\n      })\n    }\n  })\n  ################### functions ###################\n  \n  #function to return list of probes that\n  filterProbes <- function(elist, threshVal, percentSamples) {\n    if (threshVal == \"Global Mean\") {\n      #get global mean\n      eMatrix <- elist$E\n      eArea <- nrow(eMatrix) * ncol(eMatrix)\n      eAvg <- sum(eMatrix) / eArea\n      \n      #convert into T/F matrix of greater than global average\n      eMatrixTF <- (eMatrix > eAvg)\n      \n      mirRowSumVector <- rowSums(eMatrixTF)#numeric()\n      \"i'm pretty sure this is just rowsums\n      for (i in 1:nrow(eMatrix)) {\n      mirRowSumVector <- c(mirRowSumVector, sum(eMatrixTF[i,]))\n      }\n      \"\n      mirKeep <-\n        mirRowSumVector > percentSamples * ncol(eMatrix) / 100\n      return(mirKeep)\n    }\n    else{\n      eMatrix <- elist$E\n      #convert into T/F matrix of greater than global average\n      eMatrixTF <- (eMatrix > threshVal)\n      \n      mirRowSumVector <- rowSums(eMatrixTF)#numeric()\n      \"\n      for (i in 1:nrow(eMatrix)) {\n      mirRowSumVector <- c(mirRowSumVector, sum(eMatrixTF[i,]))\n      }\n      \"\n      mirKeep <-\n        mirRowSumVector > percentSamples * ncol(eMatrix) / 100\n      return(mirKeep)\n    }\n  }\n  \n  win <- function(filepath){\n    is.windows <- FALSE\n    \n    if(is.windows){\n      filepath <- gsub(\"/\", \"\\\\\\\\\",filepath)\n    }\n    return(filepath)\n  }\n  \n  normalizeMatrix <- function(method, E, housekeepVector, voom) {\n    if (method == \"Upper Quartile\") {\n      \n      A <- E\n      upQ <- 0\n      \n      for (i in 1:ncol(A)) {\n        col <- A[, i]\n        denom <- quantile(col[col != 0], names = FALSE)[4]\n        A[, i] <- A[, i] / denom\n        upQ <- upQ + denom\n      }\n      upQ <- upQ / ncol(A)\n      \n      A <- A * upQ\n      \n    } else if (method == \"Total Count\") {\n      \n      A <- E\n      tc <- 0 \n      \n      for (i in 1:ncol(A)) {\n        denom <- sum(A[, i])\n        A[, i] <- (A[, i] / denom)\n        tc <- tc + denom\n      }\n      tc <- tc / ncol(A)\n      \n      A <- A * tc\n      \n    } else if (method == \"Median\") {\n      \n      A <- E\n      med <- 0\n      \n      for (i in 1:ncol(A)) {\n        col <- A[, i]\n        denom <- quantile(col[col != 0], names = FALSE)[3]\n        A[, i] <- (A[, i] / denom)\n        med <- med + denom\n      }\n      med <- med / ncol(A)\n      \n      A <- A * med\n      \n    } else if (method == \"CPM\") {\n      \n      A <- E\n      \n      for (i in 1:ncol(A)) {\n        denom <- sum(A[, i]) / 1000000\n        A[, i] <- (A[, i] / denom)\n      }\n    } else if (method == \"Housekeeping Gene\") {\n      A <- E\n      for (i in 1:ncol(A)) {\n        denom <- housekeepVector[i]\n        A[, i] <- (A[, i] / denom)\n      }\n      A <- A * 1000000\n    }else{\n      #if no approved option selected\n      return(NULL)\n    }\n    if(voom){\n      A <- voom(A+0.5, plot = FALSE)$E\n    }\n    else{\n      A <- log2(A+1)\n    }\n    return(A)\n  }\n  \n  multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n    \n    # Make a list from the ... arguments and plotlist\n    plots <- c(list(...), plotlist)\n    \n    numPlots = length(plots)\n    \n    # If layout is NULL, then use 'cols' to determine layout\n    if (is.null(layout)) {\n      # Make the panel\n      # ncol: Number of columns of plots\n      # nrow: Number of rows needed, calculated from # of cols\n      layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                       ncol = cols, nrow = ceiling(numPlots/cols))\n    }\n    \n    if (numPlots==1) {\n      print(plots[[1]])\n      \n    } else {\n      # Set up the page\n      grid.newpage()\n      pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n      \n      # Make each plot, in the correct location\n      for (i in 1:numPlots) {\n        # Get the i,j matrix positions of the regions that contain this subplot\n        matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n        \n        print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                        layout.pos.col = matchidx$col))\n      }\n    }\n  }\n  \n  cleanE = function(E, mod, sv) {\n    X = cbind(mod, sv)\n    Hat = solve(t(X) %*% X) %*% t(X)\n    beta = (Hat %*% t(E))\n    rm(Hat)\n    gc()\n    P = ncol(mod)\n    return(E - t(as.matrix(X[,-c(1:P)]) %*% beta[-c(1:P),]))\n  }\n  \n  plotColor <- function(p, both = FALSE, discrete = TRUE, fill = TRUE, n = NULL, input, rev = FALSE, ...){\n    palType <- plotPalType(input)\n    pal <- plotPal(input, rev)\n    d <- 1\n    if(rev){\n      d <- -1\n    }\n    if(discrete){\n      if(n < 6){\n        n <- 6\n      }\n      if(fill){\n        if(both){\n          switch(palType,\n                 RColorBrewer = print(p + scale_fill_brewer(palette = pal, direction = d)+ scale_color_brewer(palette = pal, direction = d)),\n                 viridis = print(p + scale_fill_viridis(option = pal, discrete = TRUE, direction = d) + scale_color_viridis(option = pal, discrete = TRUE, direction = d)),\n                 manual = print(p + scale_fill_manual(values = colorRampPalette(pal)(n))+ scale_color_manual(values = colorRampPalette(pal)(n))),\n                 none = print(p))\n        } else{\n          switch(palType,\n                 RColorBrewer = print(p + scale_fill_brewer(palette = pal, direction = d)),\n                 viridis = print(p + scale_fill_viridis(option = pal, discrete = TRUE, direction = d)),\n                 manual = print(p + scale_fill_manual(values = colorRampPalette(pal)(n))),\n                 none = print(p))\n        }\n      } else{\n        switch(palType,\n               RColorBrewer = print(p + scale_color_brewer(palette = pal, direction = d)),\n               viridis = print(p + scale_color_viridis(option = pal, discrete = TRUE, direction = d)),\n               manual = print(p + scale_color_manual(values = colorRampPalette(pal)(n))),\n               none  = print(p))\n      }\n    } else {\n      if(fill){\n        switch(palType,\n               RColorBrewer = print(p + scale_fill_distiller(palette = pal, direction = d)),\n               viridis = print(p + scale_fill_viridis(option = pal, direction = d)),\n               manual = print(p + scale_fill_gradientn(colors = pal)),\n               none = print(p))\n      } else{\n        switch(palType,\n               RColorBrewer = print(p + scale_color_distiller(palette = pal, direction = d)),\n               viridis = print(p + scale_color_viridis(option = pal, direction = d)),\n               manual = print(p + scale_color_continuous(colors = pal)),\n               none = print(p))\n      }\n    }\n  } \n  \n  \n  \n  plotOrderBoxplot<- function(orderVector = NULL, E, lab, title, cont = FALSE){\n    if(is.null(orderVector)){\n      orderVector <- 1:ncol(E)\n    }\n    incProgress(0.333, detail = \"Applying sample order\")\n    \n    pOrder <- order(orderVector)\n    \n    #reorder data matrix\n    E <- E[,pOrder]\n    \n    #add S to sample #'s\n    cn <- character()\n    for(i in 1:ncol(E)){\n      cn <- c(cn, paste0(\"S\", i))\n    }\n    \n    #replace column names \n    colnames(E) <- factor(cn[pOrder])\n    \n    incProgress(0.333, detail = \"Building data frames\")\n    #form boxplot dataframe\n    m <- melt(t(E))\n    \n    #create group value column and append to df\n    m$orderVector <- rep(orderVector[pOrder], nrow(E))\n    incProgress(0.333, detail = \"Building plot\")\n    m$X1 <- factor(m$X1, levels = cn[pOrder])\n    if(cont){\n      p <- ggplot(m, aes(x = X1, y = log2(value))) + geom_boxplot(outlier.shape = 3, outlier.color = '#ff0000', width = 0.6) + ggtitle(toString(title)) + xlab(\"Sample Number\") + ylab (\"log2ExpVal\") + labs(fill = lab) \n    } else{\n      p <- ggplot(m, aes(x = X1, y = log2(value), fill = factor(orderVector))) + geom_boxplot(outlier.shape = 3, outlier.color = '#ff0000', outlier.size = 1, width = 0.6) + ggtitle(toString(title)) + xlab(\"Sample Number\") + ylab (\"log2ExpVal\") + labs(fill = lab) \n    }\n    return(p)\n  }\n  \n  heatmapPal <- function(palType, rev){\n    a <- switch(\n      palType,\n      Default =  '-RdYlBu2:100',\n      YellowOrangeRed = colorRampPalette(brewer.pal(9, \"YlOrRd\"))(255),\n      YellowGreenBlue = colorRampPalette(brewer.pal(9, \"YlGnBu\"))(255),\n      RedYellowGreen = colorRampPalette(brewer.pal(11, \"RdYlGn\"))(255),\n      RedYellowBlue = colorRampPalette(brewer.pal(11, \"RdYlBu\"))(255),\n      RedBlue = colorRampPalette(brewer.pal(11, \"RdBu\"))(255),\n      Spectral = colorRampPalette(brewer.pal(11, \"Spectral\"))(255),\n      Rainbow = colorRampPalette(rainbow(6))(255),\n      RedGreenBlue = colorRampPalette(c(\"Red\", \"Green\", \"Blue\"))(255),\n      RedBlackGreen = colorRampPalette(c(\"#ff0000\", \"#800000\", '#000000', \"#008000\", \"#00ff00\"))(255),\n      Rainbow2.0 = colorRampPalette(c(\"#ff0000\", \"#ffa600\", \"#ffff00\", \"#00ff00\", \"#00ffff\", \"#0000ff\"))(255),\n      Viridis = viridis(255),\n      Magma = viridis(255, option = \"A\"),\n      Inferno = viridis(255, option = \"B\", begin = 0),\n      Plasma = viridis(255, option = \"C\", begin = 0)\n    )\n    if(rev){\n      return(rev(a))\n    }\n    return(a)\n  }\n  \n  plotPal <- function(palType, rev){\n    a <- switch(\n      palType,\n      Default = NULL,\n      Greys = \"Greys\",\n      YellowOrangeRed = \"YlOrRd\",\n      YellowGreenBlue = \"YlGnBu\",\n      RedYellowGreen = \"RdYlGn\",\n      RedYellowBlue = \"RdYlBu\",\n      Set1 = \"Set1\",\n      Set2 = \"Set2\",\n      Set3 = \"Set3\",\n      RedBlue = \"RdBu\",\n      Spectral = \"Spectral\",\n      Rainbow = rainbow(6),\n      RedGreenBlue = colorRampPalette(c(\"Red\", \"Green\", \"Blue\"))(6),\n      RedBlackGreen = colorRampPalette(c(\"#ff0000\", \"#800000\", '#000000', \"#008000\", \"#00ff00\"))(6),\n      Rainbow2.0 = c(\"#ff0000\", \"#ffa600\", \"#ffff00\", \"#00ff00\", \"#00ffff\", \"#0000ff\"),\n      Viridis = \"D\",\n      Magma = \"A\",\n      Inferno = \"B\",\n      Plasma = \"C\"\n    )\n    if(rev){\n      return(rev(a))\n    }\n    return(a)\n  }\n  plotPalType <- function(pal){\n    a <- switch(\n      pal,\n      Default = \"none\",\n      Greys = \"RColorBrewer\",\n      YellowOrangeRed = \"RColorBrewer\",\n      YellowGreenBlue = \"RColorBrewer\",\n      RedYellowGreen = \"RColorBrewer\",\n      RedYellowBlue = \"RColorBrewer\",\n      Set1 = \"RColorBrewer\",\n      Set2 = \"RColorBrewer\",\n      Set3 = \"RColorBrewer\",\n      RedBlue = \"RColorBrewer\",\n      Spectral = \"RColorBrewer\",\n      Rainbow = \"manual\",\n      RedGreenBlue = \"manual\",\n      RedBlackGreen = \"manual\",\n      Rainbow2.0 = \"manual\",\n      Viridis = \"viridis\",\n      Magma = \"viridis\",\n      Inferno = \"viridis\",\n      Plasma = \"viridis\"\n    )\n    return(a)\n  }\n  #copy of est_power_curve but improved plotting options\n  est_power_curve_better = function (n, w = 1, rho = 2, lambda0 = 5, phi0 = 1, alpha = 0.05, \n                                     f = 0.05, stepsize = 5, squarestep = F, usegradient = T, gradientdetail = 50,\n                                     distributionObject, repNumber = 10,...) \n  {\n    powerList <- NULL\n    sampleSizeList = NULL\n    withProgress({\n      if(usegradient) { #step based on the gradient, if gradient is tiny, step larger\n        i = 1\n        sampleSizeList = 1      \n        while(sampleSizeList[i] <= n) {\n          setProgress(sampleSizeList[i]/n, message = \"Generating power values\")\n          if(is.null(distributionObject) || missing(distributionObject)) {\n            if (!missing(f)) {\n              powerList[i] <- est_power(n = sampleSizeList[i], \n                                        w = w, rho = rho, lambda0 = lambda0, phi0 = phi0, \n                                        f = f, ...)\n            }\n            else {\n              powerList[i] <- est_power(n = sampleSizeList[i], \n                                        w = w, rho = rho, lambda0 = lambda0, phi0 = phi0, \n                                        alpha = alpha, ...)\n            }\n          } else {\n            powerList[i] = est_power_distribution(n = sampleSizeList[i], f=alpha,rho=rho,distributionObject = distributionObject, repNumber = repNumber)\n          }\n          if(i > 1) {\n            gradient = (powerList[i] - powerList[i-1])/sqrt(sampleSizeList[i] - sampleSizeList[i-1]) #sqrt is to discourage large leaps in sample sizes\n            sampleSizeList[i+1] = sampleSizeList[i] + stepsize / (gradientdetail * gradient + 1)\n          } else {\n            sampleSizeList[i+1] = sampleSizeList[i] + stepsize\n          }\n          i = i + 1\n        } \n        #edge case\n        sampleSizeList[i] = n\n        if(is.null(distributionObject) || missing(distributionObject)) {\n          if (!missing(f)) {\n            powerList[i] <- est_power(n = sampleSizeList[i], \n                                      w = w, rho = rho, lambda0 = lambda0, phi0 = phi0, \n                                      f = f, ...)\n          }\n          else {\n            powerList[i] <- est_power(n = sampleSizeList[i], \n                                      w = w, rho = rho, lambda0 = lambda0, phi0 = phi0, \n                                      alpha = alpha, ...)\n          }\n        } else {\n          powerList[i] = est_power_distribution(n = sampleSizeList[i], f=alpha,rho=rho,distributionObject = distributionObject, repNumber = repNumber)\n        }\n      } else {\n        if(squarestep) {\n          sampleSizeList = (seq(1, n/stepsize) ^ 2) * stepsize^2/n #todo remove the extra n at the end\n        } else {\n          if (!n%%stepsize) {      \n            sampleSizeList <- c(1, seq(stepsize, n, by = stepsize))\n          }\n          else {\n            sampleSizeList <- c(1, seq(stepsize, n, by = stepsize), n)\n          }\n        }\n        for (i in 1:length(sampleSizeList)) {\n          setProgress(i/length(sampleSizeList), message = \"Generating power values\")\n          if(is.null(distributionObject) || missing(distributionObject)) {\n            if (!missing(f)) {\n              powerList[i] <- est_power(n = sampleSizeList[i], \n                                        w = w, rho = rho, lambda0 = lambda0, phi0 = phi0, \n                                        f = f, ...)\n            }\n            else {\n              powerList[i] <- est_power(n = sampleSizeList[i], \n                                        w = w, rho = rho, lambda0 = lambda0, phi0 = phi0, \n                                        alpha = alpha, ...)\n            }\n          } else {\n            powerList[i] = est_power_distribution(n = sampleSizeList[i], f=alpha,rho=rho,distributionObject = distributionObject, repNumber = repNumber)\n          }\n        }\n      }\n    })\n    process <- cbind(N = sampleSizeList, Power = powerList)\n    if (!missing(f)) {\n      parameters <- c(n, f, w, rho, lambda0, phi0)\n      names(parameters) <- c(\"n\", \"fdr\", \"w\", \"rho\", \"lambda0\", \n                             \"phi0\")\n    }\n    else {\n      parameters <- c(n, alpha, w, rho, lambda0, phi0)\n      names(parameters) <- c(\"n\", \"alpha\", \"w\", \"rho\", \"lambda0\", \n                             \"phi0\")\n    }\n    return(list(process = process, parameters = parameters, power = process[nrow(process), \n                                                                            2]))\n  }\n  #copy of function plot_power_curve but with a legend that makes sense\n  plot_power_curve_better = function (result, cexLegend = 1, type = \"b\", xlab = \"Sample Size\", \n                                      ylab = \"Power\", pch = 16, lwd = 3, las = 1, cex = 1.5, main = \"Power Curve\", \n                                      col = \"red\") \n  {\n    if (identical(names(result), c(\"iter\", \"f.root\", \"root\", \n                                   \"process\", \"parameters\")) || identical(names(result), \n                                                                          c(\"process\", \"parameters\", \"power\"))) {\n      plot(result$process[, 1], result$process[, 2], type = type, \n           xlab = xlab, ylab = ylab, pch = pch, lwd = lwd, las = las, \n           cex = cex, main = main, col = col)\n      legend(\"bottomright\", legend = paste(paste(names(result$parameters), \n                                                 result$parameters, sep = \"=\"), collapse = \";\"), bty = \"n\", \n             text.col = \"red\", cex = 0.9)\n      abline(h = result$parameters[\"power\"], lty = 2, col = \"grey\")\n    }\n    else {\n      if (length(result) > 5) {\n        result <- result[(length(result) - 4):length(result)]\n        warning(\"At most 5 curves were allowed in plot_power_curve function, the last 5 in result parameter will be used\")\n      }\n      resultRange <- apply(sapply(result, function(x) (x$process)[nrow(x$process), \n                                                                  ]), 1, max)\n      plot(c(0, resultRange[1]), c(0, resultRange[2]), type = \"n\", \n           xlab = xlab, ylab = ylab, las = las, main = main)\n      col <- c(\"brown1\", \"steelblue2\", \"mediumpurple2\", \"seagreen3\", \n               \"lightgoldenrod\")\n      legendEach <- \"\"\n      for (x in 1:length(result)) {\n        resultEach <- result[[x]]\n        lines(resultEach$process[, 1], resultEach$process[, \n                                                          2], type = \"b\", pch = 16, lwd = 3, cex = 1.5, \n              col = col[x])\n      }\n      legendEach = paste(\"Power Graph\",1:length(result))\n      abline(h = result[[length(result)]]$parameters[\"power\"], \n             lty = 2, col = \"grey\")\n      legend(\"bottomright\", legend = legendEach, bty = \"n\", \n             text.col = col[1:length(result)], cex = cexLegend)\n    }\n  }\n})",
    "created" : 1522892844592.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2555554550",
    "id" : "AB3CD056",
    "lastKnownWriteTime" : 1525301235,
    "last_content_update" : 1525301235492,
    "path" : "C:/Will Chen/MiRShiny2/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}